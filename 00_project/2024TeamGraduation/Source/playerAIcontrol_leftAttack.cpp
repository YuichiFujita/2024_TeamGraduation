//=============================================================================
// 
//  プレイヤーコントロール処理 [playercontrol.cpp]
//  Author : 相馬靜雅
// 
//=============================================================================
#include "playerAIcontrol_leftAttack.h"
#include "manager.h"
#include "calculation.h"
#include "input.h"
#include "camera.h"
#include "game.h"
#include "teamStatus.h"

// デバッグ用
#include "3D_effect.h"

// player関連
#include "playerBase.h"
#include "playerStatus.h"
#include "playerAIcontrol_action.h"
#include "playerAIcontrol_move.h"
#include "playerManager.h"

//==========================================================================
// 定数定義
//==========================================================================
namespace
{

};

//==========================================================================
// コンストラクタ
//==========================================================================
CPlayerAIControlLeftAttack::CPlayerAIControlLeftAttack()
{

}

#if 1
//==========================================================================
// 生成
//==========================================================================
CPlayerAIControlLeftAttack* CPlayerAIControlLeftAttack::Create(CPlayer* player)
{
	// メモリの確保
	CPlayerAIControlLeftAttack* pObj = DEBUG_NEW CPlayerAIControlLeftAttack;
	if (pObj != nullptr)
	{
		// クラスの初期化
		if (FAILED(pObj->Init()))
		{ // 初期化に失敗した場合

			// クラスの終了
			SAFE_UNINIT(pObj);
			return nullptr;
		}
	}

	return pObj;
}
#endif

//==========================================================================
// 初期化処理
//==========================================================================
HRESULT CPlayerAIControlLeftAttack::Init()
{
	CPlayerAIControlAttack::Init();

	return S_OK;
}

//==========================================================================
// 終了処理
//==========================================================================
void CPlayerAIControlLeftAttack::Uninit()
{
	CPlayerAIControlAttack::Uninit();
}

//==========================================================================
// 更新処理
//==========================================================================
void CPlayerAIControlLeftAttack::Update(const float fDeltaTime, const float fDeltaRate, const float fSlowRate)
{
	CPlayerAIControlAttack::Update(fDeltaTime, fDeltaRate, fSlowRate);
}

//==========================================================================
// 走り投げ
//==========================================================================
void CPlayerAIControlLeftAttack::AttackDash(CPlayer* pTarget)
{
	// ターゲットの取得
	if (!pTarget) return;
	MyLib::Vector3 posTarget = pTarget->GetPosition();

	// 自分の情報
	CPlayer* pMy = GetPlayer();
	if (!pMy) return;
	MyLib::Vector3 posMy = pMy->GetPosition();

	// ラインの位置
	MyLib::Vector3 linePos = { 0.0f, posMy.y, posMy.z };

	// ラインとの距離
	float distanceLine = 0.0f;
	float distanceTarget = 0.0f;
	float JUMP_LENGTH_TARGET = 500.0f;
	float JUMP_LENGTH_LINE = 300.0f;

	// ターゲットのエリアの取得
	CGameManager::ETeamSide side = pMy->GetTeam();

	if (pTarget)
	{// ターゲットがいた場合
		distanceTarget = posMy.DistanceXZ(pTarget->GetPosition());	// 自分と相手の距離
		distanceLine = posMy.DistanceXZ(linePos);	// 自分と中心線との距離
	}
	else
	{
		return;
	}

	//if (distanceTarget > JUMP_LENGTH_TARGET && distanceLine > JUMP_LENGTH_LINE)
	//{// 自分とターゲットの距離が500.0f以上&&中央線との距離が範囲以上の場合

	//	// 走る
	//	SetMoveFlag(EMoveFlag::MOVEFLAG_DASH);

	//	// 相手の位置に近づく
	//	if (Approatch(posTarget, JUMP_LENGTH_LINE))
	//	{// 範囲内の場合
	//		//SetForcibly(EMoveForcibly::FORCIBLY_NONE);	// 強制行動：なし
	//		SetMoveFlag(EMoveFlag::MOVEFLAG_IDLE);			// 行動：止まる
	//	}

	//	return;
	//}

	//if (distanceTarget > JUMP_LENGTH_TARGET)
	//{// ターゲットとの距離が範囲以上&&中央線との距離が範囲内の場合
	//	SetActionFlag(EActionFlag::ACTION_JUMP);	// アクション：跳ぶ
	//}
	//else
	//{
	//	SetMoveFlag(EMoveFlag::MOVEFLAG_IDLE);		// 行動：止まる
	//	SetThrowFlag(EThrowFlag::THROW_NORMAL);		// 投げ：投げる
	//}

	//if (pMy->GetPosition().y >= playerAIcontrol::THROW_JUMP_END)	// 高さによって変わる
	//{
	//	SetMoveFlag(EMoveFlag::MOVEFLAG_IDLE);		// 行動：止まる
	//	SetThrowFlag(EThrowFlag::THROW_NORMAL);		// 投げ：投げる
	//}
}
